{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber'; // import Web3 from 'web3'\n\nimport * as Types from './types.js';\nimport { // SUBTRACT_GAS_LIMIT,\ncontractAddresses, supportedPools } from './constants.js';\nimport UNIV2PairAbi from './abi/uni_v2_lp.json';\nimport FarmAbi from './abi/farm.json';\nimport ERC20Abi from './abi/erc20.json';\nimport ERC20V2Abi from './abi/erc20v2.json';\nimport WETHAbi from './abi/weth.json';\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3;\n    this.defaultConfirmations = options.defaultConfirmations;\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5;\n    this.confirmationType = options.confirmationType || Types.ConfirmationType.Confirmed;\n    this.defaultGas = options.defaultGas;\n    this.defaultGasPrice = options.defaultGasPrice;\n    this.erc20 = new this.web3.eth.Contract(ERC20Abi);\n    this.erc20v2 = new this.web3.eth.Contract(ERC20Abi);\n    this.farm = new this.web3.eth.Contract(FarmAbi);\n    this.weth = new this.web3.eth.Contract(WETHAbi);\n    this.pools = supportedPools.map(pool => Object.assign(pool, {\n      lpAddress: pool.lpAddresses[networkId],\n      tokenAddress: pool.tokenAddresses[networkId],\n      lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n      tokenContract: pool.version === 'V1' ? new this.web3.eth.Contract(ERC20Abi) : new this.web3.eth.Contract(ERC20Abi)\n    }));\n    this.setProvider(provider, networkId);\n    this.setDefaultAccount(this.web3.eth.defaultAccount);\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider);\n      if (address) contract.options.address = address;else console.error('Contract address not found in network', networkId);\n    };\n\n    setProvider(this.erc20, contractAddresses.erc20[networkId]);\n    setProvider(this.erc20, contractAddresses.erc20[networkId]);\n    setProvider(this.farm, contractAddresses.farm[networkId]);\n    setProvider(this.weth, contractAddresses.weth[networkId]);\n    this.pools.forEach(_ref => {\n      let {\n        lpContract,\n        lpAddress,\n        tokenContract,\n        tokenAddress\n      } = _ref;\n      setProvider(lpContract, lpAddress);\n      setProvider(tokenContract, tokenAddress);\n    });\n  }\n\n  setDefaultAccount(account) {\n    this.erc20.options.from = account;\n    this.erc20.options.from = account;\n    this.farm.options.from = account;\n  } // async callContractFunction(method, options) {\n  //   const {\n  //     confirmations,\n  //     confirmationType,\n  //     autoGasMultiplier,\n  //     ...txOptions\n  //   } = options\n  //\n  //   if (!this.blockGasLimit) {\n  //     await this.setGasLimit()\n  //   }\n  //\n  //   if (!txOptions.gasPrice && this.defaultGasPrice) {\n  //     txOptions.gasPrice = this.defaultGasPrice\n  //   }\n  //\n  //   if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n  //     let gasEstimate\n  //     if (\n  //       this.defaultGas &&\n  //       confirmationType !== Types.ConfirmationType.Simulate\n  //     ) {\n  //       txOptions.gas = this.defaultGas\n  //     } else {\n  //       try {\n  //         console.log('estimating gas')\n  //         gasEstimate = await method.estimateGas(txOptions)\n  //       } catch (error) {\n  //         const data = method.encodeABI()\n  //         const { from, value } = options\n  //         const to = method._parent._address\n  //         error.transactionData = { from, value, data, to }\n  //         throw error\n  //       }\n  //\n  //       const multiplier = autoGasMultiplier || this.autoGasMultiplier\n  //       const totalGas = Math.floor(gasEstimate * multiplier)\n  //       txOptions.gas =\n  //         totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit\n  //     }\n  //\n  //     if (confirmationType === Types.ConfirmationType.Simulate) {\n  //       let g = txOptions.gas\n  //       return { gasEstimate, g }\n  //     }\n  //   }\n  //\n  //   if (txOptions.value) {\n  //     txOptions.value = new BigNumber(txOptions.value).toFixed(0)\n  //   } else {\n  //     txOptions.value = '0'\n  //   }\n  //\n  //   const promi = method.send(txOptions)\n  //\n  //   const OUTCOMES = {\n  //     INITIAL: 0,\n  //     RESOLVED: 1,\n  //     REJECTED: 2,\n  //   }\n  //\n  //   let hashOutcome = OUTCOMES.INITIAL\n  //   let confirmationOutcome = OUTCOMES.INITIAL\n  //\n  //   const t =\n  //     confirmationType !== undefined ? confirmationType : this.confirmationType\n  //\n  //   if (!Object.values(Types.ConfirmationType).includes(t)) {\n  //     throw new Error(`Invalid confirmation type: ${t}`)\n  //   }\n  //\n  //   let hashPromise\n  //   let confirmationPromise\n  //\n  //   if (\n  //     t === Types.ConfirmationType.Hash ||\n  //     t === Types.ConfirmationType.Both\n  //   ) {\n  //     hashPromise = new Promise((resolve, reject) => {\n  //       promi.on('error', (error) => {\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\n  //           hashOutcome = OUTCOMES.REJECTED\n  //           reject(error)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         }\n  //       })\n  //\n  //       promi.on('transactionHash', (txHash) => {\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\n  //           hashOutcome = OUTCOMES.RESOLVED\n  //           resolve(txHash)\n  //           if (t !== Types.ConfirmationType.Both) {\n  //             const anyPromi = promi\n  //             anyPromi.off()\n  //           }\n  //         }\n  //       })\n  //     })\n  //   }\n  //\n  //   if (\n  //     t === Types.ConfirmationType.Confirmed ||\n  //     t === Types.ConfirmationType.Both\n  //   ) {\n  //     confirmationPromise = new Promise((resolve, reject) => {\n  //       promi.on('error', (error) => {\n  //         if (\n  //           (t === Types.ConfirmationType.Confirmed ||\n  //             hashOutcome === OUTCOMES.RESOLVED) &&\n  //           confirmationOutcome === OUTCOMES.INITIAL\n  //         ) {\n  //           confirmationOutcome = OUTCOMES.REJECTED\n  //           reject(error)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         }\n  //       })\n  //\n  //       const desiredConf = confirmations || this.defaultConfirmations\n  //       if (desiredConf) {\n  //         promi.on('confirmation', (confNumber, receipt) => {\n  //           if (confNumber >= desiredConf) {\n  //             if (confirmationOutcome === OUTCOMES.INITIAL) {\n  //               confirmationOutcome = OUTCOMES.RESOLVED\n  //               resolve(receipt)\n  //               const anyPromi = promi\n  //               anyPromi.off()\n  //             }\n  //           }\n  //         })\n  //       } else {\n  //         promi.on('receipt', (receipt) => {\n  //           confirmationOutcome = OUTCOMES.RESOLVED\n  //           resolve(receipt)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         })\n  //       }\n  //     })\n  //   }\n  //\n  //   if (t === Types.ConfirmationType.Hash) {\n  //     const transactionHash = await hashPromise\n  //     if (this.notifier) {\n  //       this.notifier.hash(transactionHash)\n  //     }\n  //     return { transactionHash }\n  //   }\n  //\n  //   if (t === Types.ConfirmationType.Confirmed) {\n  //     return confirmationPromise\n  //   }\n  //\n  //   const transactionHash = await hashPromise\n  //   if (this.notifier) {\n  //     this.notifier.hash(transactionHash)\n  //   }\n  //   return {\n  //     transactionHash,\n  //     confirmation: confirmationPromise,\n  //   }\n  // }\n  // async callConstantContractFunction(method, options) {\n  //   const m2 = method\n  //   const { blockNumber, ...txOptions } = options\n  //   return m2.call(txOptions, blockNumber)\n  // }\n  // async setGasLimit() {\n  //   const block = await this.web3.eth.getBlock('latest')\n  //   this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT\n  // }\n\n\n}","map":{"version":3,"sources":["/home/fibo/Documents/workspace/front-lp-stack/src/farm/lib/contracts.js"],"names":["BigNumber","Types","contractAddresses","supportedPools","UNIV2PairAbi","FarmAbi","ERC20Abi","ERC20V2Abi","WETHAbi","Contracts","constructor","provider","networkId","web3","options","defaultConfirmations","autoGasMultiplier","confirmationType","ConfirmationType","Confirmed","defaultGas","defaultGasPrice","erc20","eth","Contract","erc20v2","farm","weth","pools","map","pool","Object","assign","lpAddress","lpAddresses","tokenAddress","tokenAddresses","lpContract","tokenContract","version","setProvider","setDefaultAccount","defaultAccount","contract","address","console","error","forEach","account","from"],"mappings":"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MD;;AAEDM,EAAAA,iBAAiB,CAACO,OAAD,EAAU;AACzB,SAAK1B,KAAL,CAAWR,OAAX,CAAmBmC,IAAnB,GAA0BD,OAA1B;AACA,SAAK1B,KAAL,CAAWR,OAAX,CAAmBmC,IAAnB,GAA0BD,OAA1B;AACA,SAAKtB,IAAL,CAAUZ,OAAV,CAAkBmC,IAAlB,GAAyBD,OAAzB;AACD,GAvDoB,CAyDrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAtOqB","sourcesContent":["import BigNumber from 'bignumber.js/bignumber'\n// import Web3 from 'web3'\nimport * as Types from './types.js'\nimport {\n  // SUBTRACT_GAS_LIMIT,\n  contractAddresses,\n  supportedPools,\n} from './constants.js'\n\nimport UNIV2PairAbi from './abi/uni_v2_lp.json'\n\nimport FarmAbi from './abi/farm.json'\nimport ERC20Abi from './abi/erc20.json'\nimport ERC20V2Abi from './abi/erc20v2.json'\nimport WETHAbi from './abi/weth.json'\n\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3\n    this.defaultConfirmations = options.defaultConfirmations\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5\n    this.confirmationType =\n      options.confirmationType || Types.ConfirmationType.Confirmed\n    this.defaultGas = options.defaultGas\n    this.defaultGasPrice = options.defaultGasPrice\n\n    this.erc20 = new this.web3.eth.Contract(ERC20Abi)\n    this.erc20v2 = new this.web3.eth.Contract(ERC20Abi)\n    this.farm = new this.web3.eth.Contract(FarmAbi)\n    this.weth = new this.web3.eth.Contract(WETHAbi)\n\n    this.pools = supportedPools.map((pool) =>\n      Object.assign(pool, {\n        lpAddress: pool.lpAddresses[networkId],\n        tokenAddress: pool.tokenAddresses[networkId],\n        lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n        tokenContract:\n          pool.version === 'V1'\n            ? new this.web3.eth.Contract(ERC20Abi)\n            : new this.web3.eth.Contract(ERC20Abi),\n      }),\n    )\n\n    this.setProvider(provider, networkId)\n    this.setDefaultAccount(this.web3.eth.defaultAccount)\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider)\n      if (address) contract.options.address = address\n      else console.error('Contract address not found in network', networkId)\n    }\n\n    setProvider(this.erc20, contractAddresses.erc20[networkId])\n    setProvider(this.erc20, contractAddresses.erc20[networkId])\n    setProvider(this.farm, contractAddresses.farm[networkId])\n    setProvider(this.weth, contractAddresses.weth[networkId])\n\n    this.pools.forEach(\n      ({ lpContract, lpAddress, tokenContract, tokenAddress }) => {\n        setProvider(lpContract, lpAddress)\n        setProvider(tokenContract, tokenAddress)\n      },\n    )\n  }\n\n  setDefaultAccount(account) {\n    this.erc20.options.from = account\n    this.erc20.options.from = account\n    this.farm.options.from = account\n  }\n\n  // async callContractFunction(method, options) {\n  //   const {\n  //     confirmations,\n  //     confirmationType,\n  //     autoGasMultiplier,\n  //     ...txOptions\n  //   } = options\n  //\n  //   if (!this.blockGasLimit) {\n  //     await this.setGasLimit()\n  //   }\n  //\n  //   if (!txOptions.gasPrice && this.defaultGasPrice) {\n  //     txOptions.gasPrice = this.defaultGasPrice\n  //   }\n  //\n  //   if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n  //     let gasEstimate\n  //     if (\n  //       this.defaultGas &&\n  //       confirmationType !== Types.ConfirmationType.Simulate\n  //     ) {\n  //       txOptions.gas = this.defaultGas\n  //     } else {\n  //       try {\n  //         console.log('estimating gas')\n  //         gasEstimate = await method.estimateGas(txOptions)\n  //       } catch (error) {\n  //         const data = method.encodeABI()\n  //         const { from, value } = options\n  //         const to = method._parent._address\n  //         error.transactionData = { from, value, data, to }\n  //         throw error\n  //       }\n  //\n  //       const multiplier = autoGasMultiplier || this.autoGasMultiplier\n  //       const totalGas = Math.floor(gasEstimate * multiplier)\n  //       txOptions.gas =\n  //         totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit\n  //     }\n  //\n  //     if (confirmationType === Types.ConfirmationType.Simulate) {\n  //       let g = txOptions.gas\n  //       return { gasEstimate, g }\n  //     }\n  //   }\n  //\n  //   if (txOptions.value) {\n  //     txOptions.value = new BigNumber(txOptions.value).toFixed(0)\n  //   } else {\n  //     txOptions.value = '0'\n  //   }\n  //\n  //   const promi = method.send(txOptions)\n  //\n  //   const OUTCOMES = {\n  //     INITIAL: 0,\n  //     RESOLVED: 1,\n  //     REJECTED: 2,\n  //   }\n  //\n  //   let hashOutcome = OUTCOMES.INITIAL\n  //   let confirmationOutcome = OUTCOMES.INITIAL\n  //\n  //   const t =\n  //     confirmationType !== undefined ? confirmationType : this.confirmationType\n  //\n  //   if (!Object.values(Types.ConfirmationType).includes(t)) {\n  //     throw new Error(`Invalid confirmation type: ${t}`)\n  //   }\n  //\n  //   let hashPromise\n  //   let confirmationPromise\n  //\n  //   if (\n  //     t === Types.ConfirmationType.Hash ||\n  //     t === Types.ConfirmationType.Both\n  //   ) {\n  //     hashPromise = new Promise((resolve, reject) => {\n  //       promi.on('error', (error) => {\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\n  //           hashOutcome = OUTCOMES.REJECTED\n  //           reject(error)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         }\n  //       })\n  //\n  //       promi.on('transactionHash', (txHash) => {\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\n  //           hashOutcome = OUTCOMES.RESOLVED\n  //           resolve(txHash)\n  //           if (t !== Types.ConfirmationType.Both) {\n  //             const anyPromi = promi\n  //             anyPromi.off()\n  //           }\n  //         }\n  //       })\n  //     })\n  //   }\n  //\n  //   if (\n  //     t === Types.ConfirmationType.Confirmed ||\n  //     t === Types.ConfirmationType.Both\n  //   ) {\n  //     confirmationPromise = new Promise((resolve, reject) => {\n  //       promi.on('error', (error) => {\n  //         if (\n  //           (t === Types.ConfirmationType.Confirmed ||\n  //             hashOutcome === OUTCOMES.RESOLVED) &&\n  //           confirmationOutcome === OUTCOMES.INITIAL\n  //         ) {\n  //           confirmationOutcome = OUTCOMES.REJECTED\n  //           reject(error)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         }\n  //       })\n  //\n  //       const desiredConf = confirmations || this.defaultConfirmations\n  //       if (desiredConf) {\n  //         promi.on('confirmation', (confNumber, receipt) => {\n  //           if (confNumber >= desiredConf) {\n  //             if (confirmationOutcome === OUTCOMES.INITIAL) {\n  //               confirmationOutcome = OUTCOMES.RESOLVED\n  //               resolve(receipt)\n  //               const anyPromi = promi\n  //               anyPromi.off()\n  //             }\n  //           }\n  //         })\n  //       } else {\n  //         promi.on('receipt', (receipt) => {\n  //           confirmationOutcome = OUTCOMES.RESOLVED\n  //           resolve(receipt)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         })\n  //       }\n  //     })\n  //   }\n  //\n  //   if (t === Types.ConfirmationType.Hash) {\n  //     const transactionHash = await hashPromise\n  //     if (this.notifier) {\n  //       this.notifier.hash(transactionHash)\n  //     }\n  //     return { transactionHash }\n  //   }\n  //\n  //   if (t === Types.ConfirmationType.Confirmed) {\n  //     return confirmationPromise\n  //   }\n  //\n  //   const transactionHash = await hashPromise\n  //   if (this.notifier) {\n  //     this.notifier.hash(transactionHash)\n  //   }\n  //   return {\n  //     transactionHash,\n  //     confirmation: confirmationPromise,\n  //   }\n  // }\n\n  // async callConstantContractFunction(method, options) {\n  //   const m2 = method\n  //   const { blockNumber, ...txOptions } = options\n  //   return m2.call(txOptions, blockNumber)\n  // }\n\n  // async setGasLimit() {\n  //   const block = await this.web3.eth.getBlock('latest')\n  //   this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT\n  // }\n}\n"]},"metadata":{},"sourceType":"module"}